From 2af739c9139e2b76baa1d4b7c74f4971beb60a0c Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Fri, 12 Jul 2024 11:11:34 +0200
Subject: [PATCH 1/4] Allow passing extra environment variables to Xwayland

---
 src/main_wayland.cpp              | 1 +
 src/main_wayland.h                | 5 +++++
 src/xwayland/xwaylandlauncher.cpp | 9 +++++++++
 src/xwayland/xwaylandlauncher.h   | 4 ++++
 4 files changed, 19 insertions(+)

diff --git a/src/main_wayland.cpp b/src/main_wayland.cpp
index 3903ef2ae61..7caaea14b15 100644
--- a/src/main_wayland.cpp
+++ b/src/main_wayland.cpp
@@ -162,6 +162,7 @@ void ApplicationWayland::performStartup()
         m_xwayland->xwaylandLauncher()->setListenFDs(m_xwaylandListenFds);
         m_xwayland->xwaylandLauncher()->setDisplayName(m_xwaylandDisplay);
         m_xwayland->xwaylandLauncher()->setXauthority(m_xwaylandXauthority);
+        m_xwayland->xwaylandLauncher()->addEnvironmentVariables(m_xwaylandExtraEnvironment);
         m_xwayland->init();
         connect(m_xwayland.get(), &Xwl::Xwayland::started, this, &ApplicationWayland::applyXwaylandScale);
     }
diff --git a/src/main_wayland.h b/src/main_wayland.h
index 5f5408a6fbd..c4686dcfed3 100644
--- a/src/main_wayland.h
+++ b/src/main_wayland.h
@@ -42,6 +42,10 @@ public:
     {
         m_xwaylandXauthority = xauthority;
     }
+    void addExtraXWaylandEnvrionmentVariable(const QString &variable, const QString &value)
+    {
+        m_xwaylandExtraEnvironment.insert(variable, value);
+    }
     XwaylandInterface *xwayland() const override;
 #endif
     void setApplicationsToStart(const QStringList &applications)
@@ -74,6 +78,7 @@ private:
     QList<int> m_xwaylandListenFds;
     QString m_xwaylandDisplay;
     QString m_xwaylandXauthority;
+    QMap<QString, QString> m_xwaylandExtraEnvironment;
 #endif
     KConfigWatcher::Ptr m_settingsWatcher;
 };
diff --git a/src/xwayland/xwaylandlauncher.cpp b/src/xwayland/xwaylandlauncher.cpp
index 723735ea04e..80ab752b23c 100644
--- a/src/xwayland/xwaylandlauncher.cpp
+++ b/src/xwayland/xwaylandlauncher.cpp
@@ -72,6 +72,11 @@ void XwaylandLauncher::setXauthority(const QString &xauthority)
     m_xAuthority = xauthority;
 }
 
+void XwaylandLauncher::addEnvironmentVariables(const QMap<QString, QString> &extraEnvironment)
+{
+    m_extraEnvironment.insert(extraEnvironment);
+}
+
 void XwaylandLauncher::enable()
 {
     if (m_enabled) {
@@ -176,6 +181,10 @@ bool XwaylandLauncher::start()
         env.insert("WAYLAND_DEBUG", QByteArrayLiteral("1"));
     }
 
+    for (const auto &[variable, value] : m_extraEnvironment.asKeyValueRange()) {
+        env.insert(variable, value);
+    }
+
     m_xwaylandProcess = new QProcess(this);
     m_xwaylandProcess->setProgram(QStandardPaths::findExecutable("Xwayland"));
     m_xwaylandProcess->setArguments(arguments);
diff --git a/src/xwayland/xwaylandlauncher.h b/src/xwayland/xwaylandlauncher.h
index 7e54d65f2e9..e4998004b16 100644
--- a/src/xwayland/xwaylandlauncher.h
+++ b/src/xwayland/xwaylandlauncher.h
@@ -13,6 +13,7 @@
 #include "utils/filedescriptor.h"
 
 #include <QList>
+#include <QMap>
 #include <QObject>
 #include <QProcess>
 #include <QSocketNotifier>
@@ -58,6 +59,8 @@ public:
      */
     void setXauthority(const QString &xauthority);
 
+    void addEnvironmentVariables(const QMap<QString, QString> &extraEnvironment);
+
     void enable();
     void disable();
     bool start();
@@ -103,6 +106,7 @@ private:
     QList<int> m_listenFds;
     QString m_displayName;
     QString m_xAuthority;
+    QMap<QString, QString> m_extraEnvironment;
 
     bool m_enabled = false;
     int m_crashCount = 0;
-- 
GitLab


From a5c3801594979aaeffb4980f4cbe2d0896bb3920 Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Tue, 30 Jul 2024 14:35:30 +0200
Subject: [PATCH 2/4] Allow specifying file descriptors that are passed to
 Xwayland

---
 src/main_wayland.cpp              |  1 +
 src/main_wayland.h                |  9 +++++++++
 src/xwayland/xwaylandlauncher.cpp | 13 +++++++++++++
 src/xwayland/xwaylandlauncher.h   |  3 +++
 4 files changed, 26 insertions(+)

diff --git a/src/main_wayland.cpp b/src/main_wayland.cpp
index 7caaea14b15..9ca92188646 100644
--- a/src/main_wayland.cpp
+++ b/src/main_wayland.cpp
@@ -163,6 +163,7 @@ void ApplicationWayland::performStartup()
         m_xwayland->xwaylandLauncher()->setDisplayName(m_xwaylandDisplay);
         m_xwayland->xwaylandLauncher()->setXauthority(m_xwaylandXauthority);
         m_xwayland->xwaylandLauncher()->addEnvironmentVariables(m_xwaylandExtraEnvironment);
+        m_xwayland->xwaylandLauncher()->passFileDescriptors(std::move(m_xwaylandFds));
         m_xwayland->init();
         connect(m_xwayland.get(), &Xwl::Xwayland::started, this, &ApplicationWayland::applyXwaylandScale);
     }
diff --git a/src/main_wayland.h b/src/main_wayland.h
index c4686dcfed3..b7ea15298eb 100644
--- a/src/main_wayland.h
+++ b/src/main_wayland.h
@@ -11,6 +11,10 @@
 #include <KConfigWatcher>
 #include <QTimer>
 
+#include "utils/filedescriptor.h"
+
+#include <vector>
+
 namespace KWin
 {
 namespace Xwl
@@ -46,6 +50,10 @@ public:
     {
         m_xwaylandExtraEnvironment.insert(variable, value);
     }
+    void passFdToXwayland(FileDescriptor &&fd)
+    {
+        m_xwaylandFds.push_back(std::move(fd));
+    }
     XwaylandInterface *xwayland() const override;
 #endif
     void setApplicationsToStart(const QStringList &applications)
@@ -79,6 +87,7 @@ private:
     QString m_xwaylandDisplay;
     QString m_xwaylandXauthority;
     QMap<QString, QString> m_xwaylandExtraEnvironment;
+    std::vector<FileDescriptor> m_xwaylandFds;
 #endif
     KConfigWatcher::Ptr m_settingsWatcher;
 };
diff --git a/src/xwayland/xwaylandlauncher.cpp b/src/xwayland/xwaylandlauncher.cpp
index 80ab752b23c..dcd937212df 100644
--- a/src/xwayland/xwaylandlauncher.cpp
+++ b/src/xwayland/xwaylandlauncher.cpp
@@ -77,6 +77,14 @@ void XwaylandLauncher::addEnvironmentVariables(const QMap<QString, QString> &ext
     m_extraEnvironment.insert(extraEnvironment);
 }
 
+void XwaylandLauncher::passFileDescriptors(std::vector<FileDescriptor> &&fds)
+{
+    m_fdsToPreserve.reserve(m_fdsToPreserve.size() + fds.size());
+    for (auto & fd : fds) {
+        m_fdsToPreserve.emplace_back(std::move(fd));
+    }
+}
+
 void XwaylandLauncher::enable()
 {
     if (m_enabled) {
@@ -185,6 +193,10 @@ bool XwaylandLauncher::start()
         env.insert(variable, value);
     }
 
+    for (const auto &fd : m_fdsToPreserve) {
+        fdsToPass.push_back(fd.get());
+    }
+
     m_xwaylandProcess = new QProcess(this);
     m_xwaylandProcess->setProgram(QStandardPaths::findExecutable("Xwayland"));
     m_xwaylandProcess->setArguments(arguments);
@@ -204,6 +216,7 @@ bool XwaylandLauncher::start()
             }
         }
     });
+
     connect(m_xwaylandProcess, &QProcess::errorOccurred, this, &XwaylandLauncher::handleXwaylandError);
     connect(m_xwaylandProcess, &QProcess::finished, this, &XwaylandLauncher::handleXwaylandFinished);
 
diff --git a/src/xwayland/xwaylandlauncher.h b/src/xwayland/xwaylandlauncher.h
index e4998004b16..df5d3bee18a 100644
--- a/src/xwayland/xwaylandlauncher.h
+++ b/src/xwayland/xwaylandlauncher.h
@@ -61,6 +61,8 @@ public:
 
     void addEnvironmentVariables(const QMap<QString, QString> &extraEnvironment);
 
+    void passFileDescriptors(std::vector<FileDescriptor> &&fds);
+
     void enable();
     void disable();
     bool start();
@@ -107,6 +109,7 @@ private:
     QString m_displayName;
     QString m_xAuthority;
     QMap<QString, QString> m_extraEnvironment;
+    std::vector<FileDescriptor> m_fdsToPreserve;
 
     bool m_enabled = false;
     int m_crashCount = 0;
-- 
GitLab


From bfee6c948c9b58e2766038e207a95fa8bce6778d Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Fri, 12 Jul 2024 14:58:34 +0200
Subject: [PATCH 3/4] Enable Xwayland xtest input emulation without going
 through the portal

Due to the limited libei(s) API a trick is used. Let it create
a socket with an absolute path, open that path again to get a fd
referring to the socket, unlink the file and specify the socket
that Xwayland should use in the form of /proc/self/fd/$fd.
---
 src/plugins/eis/eisbackend.cpp    | 30 ++++++++++++++++++++++++++---
 src/plugins/eis/eisbackend.h      |  6 ++++--
 src/plugins/eis/eiscontext.cpp    | 32 ++++++++++++++++++++++---------
 src/plugins/eis/eiscontext.h      | 26 ++++++++++++++++++++-----
 src/xwayland/xwaylandlauncher.cpp |  3 ---
 5 files changed, 75 insertions(+), 22 deletions(-)

diff --git a/src/plugins/eis/eisbackend.cpp b/src/plugins/eis/eisbackend.cpp
index c555988dc02..b6b12061cd8 100644
--- a/src/plugins/eis/eisbackend.cpp
+++ b/src/plugins/eis/eisbackend.cpp
@@ -14,6 +14,7 @@
 #include "input.h"
 #include "keyboard_input.h"
 #include "keyboard_layout.h"
+#include "main_wayland.h"
 #include "workspace.h"
 #include "xkb.h"
 
@@ -25,19 +26,42 @@
 
 #include <libeis.h>
 
+#include <fcntl.h>
+
 #include <ranges>
 
 namespace KWin
 {
 
+#define typeName(T)                                       \
+    [] {                                                  \
+        static_assert(                                    \
+            requires { typename T; }, "T is not a type"); \
+        return #T;                                        \
+        }()
+
 EisBackend::EisBackend(QObject *parent)
     : KWin::InputBackend(parent)
     , m_serviceWatcher(new QDBusServiceWatcher(this))
 {
+#if HAVE_XWAYLAND_ENABLE_EI_PORTAL
+    // Unfortunately there is no way to pass a connected socket fd to libei like WAYLAND_SOCKET
+    // in libwayland so we are resorting to this hack
+    // https://gitlab.freedesktop.org/libinput/libei/-/issues/63
+    m_xWaylandContext = std::make_unique<XWaylandEisContext>(this);
+    FileDescriptor fd(open(m_xWaylandContext->socketName.constData(), O_PATH | O_CLOEXEC));
+    unlink(m_xWaylandContext->socketName.constData());
+    if (QByteArray(kwinApp()->metaObject()->className()) == typeName(KWin::ApplicationWayland)) {
+        auto appWayland = static_cast<ApplicationWayland *>(kwinApp());
+        appWayland->addExtraXWaylandEnvrionmentVariable(QStringLiteral("LIBEI_SOCKET"), QStringLiteral("/proc/self/fd/%1").arg(fd.get()));
+        appWayland->passFdToXwayland(std::move(fd));
+    }
+#endif
+
     m_serviceWatcher->setConnection(QDBusConnection::sessionBus());
     m_serviceWatcher->setWatchMode(QDBusServiceWatcher::WatchForUnregistration);
     connect(m_serviceWatcher, &QDBusServiceWatcher::serviceUnregistered, this, [this](const QString &service) {
-        std::erase_if(m_contexts, [&service](const std::unique_ptr<EisContext> &context) {
+        std::erase_if(m_contexts, [&service](const std::unique_ptr<DbusEisContext> &context) {
             return context->dbusService == service;
         });
         m_serviceWatcher->removeWatchedService(service);
@@ -97,14 +121,14 @@ QDBusUnixFileDescriptor EisBackend::connectToEIS(const int &capabilities, int &c
     const QString dbusService = message().service();
     static int s_cookie = 0;
     cookie = ++s_cookie;
-    m_contexts.push_back(std::make_unique<EisContext>(this, eisCapabilities, cookie, dbusService));
+    m_contexts.push_back(std::make_unique<DbusEisContext>(this, eisCapabilities, cookie, dbusService));
     m_serviceWatcher->addWatchedService(dbusService);
     return QDBusUnixFileDescriptor(m_contexts.back()->addClient());
 }
 
 void EisBackend::disconnect(int cookie)
 {
-    auto it = std::ranges::find(m_contexts, cookie, [](const std::unique_ptr<EisContext> &context) {
+    auto it = std::ranges::find(m_contexts, cookie, [](const std::unique_ptr<DbusEisContext> &context) {
         return context->cookie;
     });
     if (it != std::ranges::end(m_contexts)) {
diff --git a/src/plugins/eis/eisbackend.h b/src/plugins/eis/eisbackend.h
index a34d40369be..f04282e58cf 100644
--- a/src/plugins/eis/eisbackend.h
+++ b/src/plugins/eis/eisbackend.h
@@ -24,7 +24,8 @@ class QDBusServiceWatcher;
 
 namespace KWin
 {
-class EisContext;
+class DbusEisContext;
+class XWaylandEisContext;
 
 class EisBackend : public KWin::InputBackend, public QDBusContext
 {
@@ -46,7 +47,8 @@ public:
 private:
     QDBusServiceWatcher *m_serviceWatcher;
     RamFile m_keymapFile;
-    std::vector<std::unique_ptr<EisContext>> m_contexts;
+    std::unique_ptr<XWaylandEisContext> m_xWaylandContext;
+    std::vector<std::unique_ptr<DbusEisContext>> m_contexts;
 };
 
 }
diff --git a/src/plugins/eis/eiscontext.cpp b/src/plugins/eis/eiscontext.cpp
index 015e04108c3..2c5a8c8b40f 100644
--- a/src/plugins/eis/eiscontext.cpp
+++ b/src/plugins/eis/eiscontext.cpp
@@ -9,6 +9,8 @@
 #include "eisdevice.h"
 #include "libeis_logging.h"
 
+#include <unistd.h>
+
 namespace KWin
 {
 
@@ -52,15 +54,32 @@ public:
     std::unique_ptr<EisDevice> keyboard;
 };
 
-EisContext::EisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService)
-    : cookie(cookie)
+DbusEisContext::DbusEisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService)
+    : EisContext(backend, allowedCapabilities)
+    , cookie(cookie)
     , dbusService(dbusService)
+{
+    eis_setup_backend_fd(m_eisContext);
+}
+
+int DbusEisContext::addClient()
+{
+    return eis_backend_fd_add_client(m_eisContext);
+}
+
+XWaylandEisContext::XWaylandEisContext(KWin::EisBackend *backend)
+    : EisContext(backend, {EIS_DEVICE_CAP_POINTER | EIS_DEVICE_CAP_POINTER_ABSOLUTE | EIS_DEVICE_CAP_KEYBOARD | EIS_DEVICE_CAP_TOUCH | EIS_DEVICE_CAP_SCROLL | EIS_DEVICE_CAP_BUTTON})
+    , socketName(qgetenv("XDG_RUNTIME_DIR") + QByteArrayLiteral("/kwin-xwayland-eis-socket.") + QByteArray::number(getpid()))
+{
+    eis_setup_backend_socket(m_eisContext, socketName.constData());
+}
+
+EisContext::EisContext(KWin::EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities)
+    : m_eisContext(eis_new(this))
     , m_backend(backend)
-    , m_eisContext(eis_new(this))
     , m_allowedCapabilities(allowedCapabilities)
     , m_socketNotifier(eis_get_fd(m_eisContext), QSocketNotifier::Read)
 {
-    eis_setup_backend_fd(m_eisContext);
     eis_log_set_priority(m_eisContext, EIS_LOG_PRIORITY_DEBUG);
     eis_log_set_handler(m_eisContext, eis_log_handler);
     QObject::connect(&m_socketNotifier, &QSocketNotifier::activated, [this] {
@@ -101,11 +120,6 @@ void EisContext::updateKeymap()
     }
 }
 
-int EisContext::addClient()
-{
-    return eis_backend_fd_add_client(m_eisContext);
-}
-
 static std::chrono::microseconds currentTime()
 {
     return std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now().time_since_epoch());
diff --git a/src/plugins/eis/eiscontext.h b/src/plugins/eis/eiscontext.h
index fd8f676a4f3..50de947a856 100644
--- a/src/plugins/eis/eiscontext.h
+++ b/src/plugins/eis/eiscontext.h
@@ -24,24 +24,40 @@ struct EisClient;
 class EisContext
 {
 public:
-    EisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService);
+    EisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities);
     ~EisContext();
 
-    int addClient();
     void updateScreens();
     void updateKeymap();
 
-    const int cookie;
-    const QString dbusService;
+protected:
+    eis *m_eisContext;
 
 private:
     void handleEvents();
 
     EisBackend *m_backend;
-    eis *m_eisContext;
     QFlags<eis_device_capability> m_allowedCapabilities;
     QSocketNotifier m_socketNotifier;
     std::vector<std::unique_ptr<EisClient>> m_clients;
 };
 
+class DbusEisContext : public EisContext
+{
+public:
+    DbusEisContext(EisBackend *backend, QFlags<eis_device_capability> allowedCapabilities, int cookie, const QString &dbusService);
+
+    int addClient();
+
+    const int cookie;
+    const QString dbusService;
+};
+
+class XWaylandEisContext : public EisContext
+{
+public:
+    XWaylandEisContext(EisBackend *backend);
+
+    const QByteArray socketName;
+};
 }
diff --git a/src/xwayland/xwaylandlauncher.cpp b/src/xwayland/xwaylandlauncher.cpp
index dcd937212df..df0325862ff 100644
--- a/src/xwayland/xwaylandlauncher.cpp
+++ b/src/xwayland/xwaylandlauncher.cpp
@@ -176,9 +176,6 @@ bool XwaylandLauncher::start()
     fdsToPass << wmfd->fds[1].get();
 
     arguments << QStringLiteral("-rootless");
-#if HAVE_XWAYLAND_ENABLE_EI_PORTAL
-    arguments << QStringLiteral("-enable-ei-portal");
-#endif
 
     QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
 
-- 
GitLab


From bead0e3419bc902a92b0b71c97e0983244c00f1f Mon Sep 17 00:00:00 2001
From: David Redondo <kde@david-redondo.de>
Date: Fri, 12 Jul 2024 15:55:59 +0200
Subject: [PATCH 4/4] Add an option to control whether xwayland xtest will
 prompt or not

Users may want to enable this for example if they often use things
which rely on xtest.
Instead of XWayland having to go through the portal we make a
special socket that XWayland can connect to if enabled.
---
 src/kcms/xwayland/CMakeLists.txt             |  1 +
 src/kcms/xwayland/kcmkwinxwayland.cpp        | 22 ++++++++++++
 src/kcms/xwayland/kcmkwinxwayland.h          |  7 ++++
 src/kcms/xwayland/kwinxwaylandsettings.kcfg  |  3 ++
 src/kcms/xwayland/kwinxwaylandsettings.kcfgc |  1 +
 src/kcms/xwayland/ui/main.qml                | 37 ++++++++++++++++++++
 src/kwin.kcfg                                |  3 ++
 src/options.cpp                              | 11 ++++++
 src/options.h                                | 11 ++++++
 src/plugins/eis/CMakeLists.txt               |  2 +-
 src/plugins/eis/eisbackend.cpp               | 23 ++++++------
 src/xwayland/xwaylandlauncher.cpp            |  6 ++++
 12 files changed, 116 insertions(+), 11 deletions(-)

diff --git a/src/kcms/xwayland/CMakeLists.txt b/src/kcms/xwayland/CMakeLists.txt
index 8e26318aa73..69aa3ae774f 100644
--- a/src/kcms/xwayland/CMakeLists.txt
+++ b/src/kcms/xwayland/CMakeLists.txt
@@ -18,5 +18,6 @@ target_link_libraries(kcm_kwinxwayland PRIVATE
     KF6::I18n
     KF6::KCMUtils
     KF6::KCMUtilsQuick
+    Qt::DBus
     Wayland::Client
 )
diff --git a/src/kcms/xwayland/kcmkwinxwayland.cpp b/src/kcms/xwayland/kcmkwinxwayland.cpp
index fc2337e3c0a..d2b94025f3d 100644
--- a/src/kcms/xwayland/kcmkwinxwayland.cpp
+++ b/src/kcms/xwayland/kcmkwinxwayland.cpp
@@ -10,6 +10,10 @@
 #include <KDesktopFile>
 #include <KLocalizedString>
 #include <KPluginFactory>
+
+#include <QDBusConnection>
+#include <QDBusMessage>
+#include <QDBusPendingCall>
 #include <QKeySequence>
 
 #include <kwinxwaylanddata.h>
@@ -25,6 +29,24 @@ KcmXwayland::KcmXwayland(QObject *parent, const KPluginMetaData &metaData)
     qmlRegisterAnonymousType<KWinXwaylandSettings>("org.kde.kwin.kwinxwaylandsettings", 1);
 }
 
+void KcmXwayland::logout() const
+{
+    auto method = QDBusMessage::createMethodCall(QStringLiteral("org.kde.LogoutPrompt"),
+                                                 QStringLiteral("/LogoutPrompt"),
+                                                 QStringLiteral("org.kde.LogoutPrompt"),
+                                                 QStringLiteral("promptLogout"));
+    QDBusConnection::sessionBus().asyncCall(method);
+}
+
+void KcmXwayland::save()
+{
+    bool modifiedXwaylandEis = m_settings->xwaylandEisNoPromptItem()->isSaveNeeded();
+    KQuickManagedConfigModule::save();
+    if (modifiedXwaylandEis) {
+        Q_EMIT showLogoutMessage();
+    }
+}
+
 KcmXwayland::~KcmXwayland() = default;
 
 #include "kcmkwinxwayland.moc"
diff --git a/src/kcms/xwayland/kcmkwinxwayland.h b/src/kcms/xwayland/kcmkwinxwayland.h
index 4c53e2931c9..1f678ff0e7e 100644
--- a/src/kcms/xwayland/kcmkwinxwayland.h
+++ b/src/kcms/xwayland/kcmkwinxwayland.h
@@ -27,6 +27,13 @@ public:
         return m_settings;
     }
 
+    void save() override;
+
+    Q_INVOKABLE void logout() const;
+
+Q_SIGNALS:
+    void showLogoutMessage();
+
 private:
     void refresh();
 
diff --git a/src/kcms/xwayland/kwinxwaylandsettings.kcfg b/src/kcms/xwayland/kwinxwaylandsettings.kcfg
index 93ecbbfdcfb..930d31a2c99 100644
--- a/src/kcms/xwayland/kwinxwaylandsettings.kcfg
+++ b/src/kcms/xwayland/kwinxwaylandsettings.kcfg
@@ -17,5 +17,8 @@
         <entry name="xwaylandEavesdropsMouse" key="XwaylandEavesdropsMouse" type="Bool">
             <default>false</default>
         </entry>
+        <entry name="XwaylandEisNoPrompt" type="Bool">
+            <default>false</default>
+        </entry>
     </group>
 </kcfg>
diff --git a/src/kcms/xwayland/kwinxwaylandsettings.kcfgc b/src/kcms/xwayland/kwinxwaylandsettings.kcfgc
index 9660d4fe5e2..4344685fced 100644
--- a/src/kcms/xwayland/kwinxwaylandsettings.kcfgc
+++ b/src/kcms/xwayland/kwinxwaylandsettings.kcfgc
@@ -5,4 +5,5 @@ DefaultValueGetters=true
 GenerateProperties=true
 ParentInConstructor=true
 Notifiers=true
+ItemAccessors=true
 GlobalEnums=true
diff --git a/src/kcms/xwayland/ui/main.qml b/src/kcms/xwayland/ui/main.qml
index f0e6dce7206..d883cadf2b5 100644
--- a/src/kcms/xwayland/ui/main.qml
+++ b/src/kcms/xwayland/ui/main.qml
@@ -19,6 +19,29 @@ KCM.SimpleKCM {
     implicitWidth: Kirigami.Units.gridUnit * 48
     implicitHeight: Kirigami.Units.gridUnit * 33
 
+     header: Kirigami.InlineMessage {
+        id: takeEffectNextTimeMsg
+        Layout.fillWidth: true
+        type: Kirigami.MessageType.Information
+        position: Kirigami.InlineMessage.Position.Header
+        text: i18nc("@info", "Changes will take effect the next time you log in.")
+        actions: [
+            Kirigami.Action {
+                icon.name: "system-log-out-symbolic"
+                text: i18nc("@action:button", "Log Out Now")
+                onTriggered: {
+                    kcm.logout()
+                }
+            }
+        ]
+        Connections {
+            target: kcm
+            function onShowLogoutMessage() {
+                takeEffectNextTimeMsg.visible = true;
+            }
+        }
+    }
+
     ColumnLayout {
         id: column
         spacing: Kirigami.Units.smallSpacing
@@ -37,6 +60,7 @@ KCM.SimpleKCM {
         }
 
         Kirigami.FormLayout {
+            id: eavesdropLayout
             Layout.leftMargin: Kirigami.Units.gridUnit
             Layout.rightMargin: Kirigami.Units.gridUnit
 
@@ -111,5 +135,18 @@ KCM.SimpleKCM {
             text: i18n("Note that using this setting will reduce system security to that of the X11 session by permitting malicious software to steal passwords and spy on the text that you type. Make sure you understand and accept this risk.")
             visible: always.checked
         }
+
+        Kirigami.Separator {
+            Layout.fillWidth: true
+            Layout.leftMargin: Kirigami.Units.gridUnit
+            Layout.rightMargin: Kirigami.Units.gridUnit
+        }
+
+        QQC2.CheckBox {
+            Layout.margins: Kirigami.Units.gridUnit
+            text: i18nc("@option:check", "Allow controlling the pointer and keyboard without asking for permission")
+            checked: kcm.settings.xwaylandEisNoPrompt
+            onToggled: kcm.settings.xwaylandEisNoPrompt = checked
+        }
     }
 }
diff --git a/src/kwin.kcfg b/src/kwin.kcfg
index 985696ef2cf..7e2e5875a5b 100644
--- a/src/kwin.kcfg
+++ b/src/kwin.kcfg
@@ -330,5 +330,8 @@
         <entry name="XwaylandEavesdropsMouse" type="Bool">
             <default>false</default>
         </entry>
+        <entry name="XwaylandEisNoPrompt" type="Bool">
+            <default>false</default>
+        </entry>
     </group>
 </kcfg>
diff --git a/src/options.cpp b/src/options.cpp
index 9c23b7cf812..5f1e1247f4a 100644
--- a/src/options.cpp
+++ b/src/options.cpp
@@ -56,6 +56,7 @@ Options::Options(QObject *parent)
     , m_xwaylandMaxCrashCount(Options::defaultXwaylandMaxCrashCount())
     , m_xwaylandEavesdrops(Options::defaultXwaylandEavesdrops())
     , m_xwaylandEavesdropsMouse(Options::defaultXwaylandEavesdropsMouse())
+    , m_xwaylandEisNoPrompt(Options::defaultXwaylandEisNoPrompt())
     , m_compositingMode(Options::defaultCompositingMode())
     , OpTitlebarDblClick(Options::defaultOperationTitlebarDblClick())
     , CmdActiveTitlebar1(Options::defaultCommandActiveTitlebar1())
@@ -158,6 +159,15 @@ void Options::setXwaylandEavesdropsMouse(bool eavesdropsMouse)
     Q_EMIT xwaylandEavesdropsChanged();
 }
 
+void Options::setXWaylandEisNoPrompt(bool doNotPrompt)
+{
+    if (m_xwaylandEisNoPrompt == doNotPrompt) {
+        return;
+    }
+    m_xwaylandEisNoPrompt = doNotPrompt;
+    Q_EMIT xwaylandEisNoPromptChanged();
+}
+
 void Options::setClickRaise(bool clickRaise)
 {
     if (m_autoRaise) {
@@ -677,6 +687,7 @@ void Options::syncFromKcfgc()
     setXwaylandMaxCrashCount(m_settings->xwaylandMaxCrashCount());
     setXwaylandEavesdrops(XwaylandEavesdropsMode(m_settings->xwaylandEavesdrops()));
     setXwaylandEavesdropsMouse(m_settings->xwaylandEavesdropsMouse());
+    setXWaylandEisNoPrompt(m_settings->xwaylandEisNoPrompt());
     setPlacement(m_settings->placement());
     setAutoRaise(m_settings->autoRaise());
     setAutoRaiseInterval(m_settings->autoRaiseInterval());
diff --git a/src/options.h b/src/options.h
index 5773c7d005b..e6312aaf1e5 100644
--- a/src/options.h
+++ b/src/options.h
@@ -246,6 +246,10 @@ public:
     {
         return m_xwaylandEavesdropsMouse;
     }
+    bool xwaylandEisNoPrompt() const
+    {
+        return m_xwaylandEisNoPrompt;
+    }
 
     /**
      * Whether clicking on a window raises it in FocusFollowsMouse
@@ -637,6 +641,7 @@ public:
     void setXwaylandMaxCrashCount(int maxCrashCount);
     void setXwaylandEavesdrops(XwaylandEavesdropsMode mode);
     void setXwaylandEavesdropsMouse(bool eavesdropsMouse);
+    void setXWaylandEisNoPrompt(bool doNotPrompt);
     void setNextFocusPrefersMouse(bool nextFocusPrefersMouse);
     void setClickRaise(bool clickRaise);
     void setAutoRaise(bool autoRaise);
@@ -785,6 +790,10 @@ public:
     {
         return false;
     }
+    static bool defaultXwaylandEisNoPrompt()
+    {
+        return false;
+    }
     static ActivationDesktopPolicy defaultActivationDesktopPolicy()
     {
         return ActivationDesktopPolicy::SwitchToOtherDesktop;
@@ -804,6 +813,7 @@ Q_SIGNALS:
     void xwaylandMaxCrashCountChanged();
     void xwaylandEavesdropsChanged();
     void xwaylandEavesdropsMouseChanged();
+    void xwaylandEisNoPromptChanged();
     void nextFocusPrefersMouseChanged();
     void clickRaiseChanged();
     void autoRaiseChanged();
@@ -883,6 +893,7 @@ private:
     int m_xwaylandMaxCrashCount;
     XwaylandEavesdropsMode m_xwaylandEavesdrops;
     bool m_xwaylandEavesdropsMouse;
+    bool m_xwaylandEisNoPrompt;
 
     CompositingType m_compositingMode;
     WindowOperation OpTitlebarDblClick;
diff --git a/src/plugins/eis/CMakeLists.txt b/src/plugins/eis/CMakeLists.txt
index 61ac515d99f..ed583fbd3f3 100644
--- a/src/plugins/eis/CMakeLists.txt
+++ b/src/plugins/eis/CMakeLists.txt
@@ -28,4 +28,4 @@ target_sources(eis PRIVATE
     eisinputcapturefilter.cpp
 )
 
-target_link_libraries(eis PRIVATE kwin KF6::I18n KF6::GlobalAccel Libeis::Libeis XKB::XKB)
+target_link_libraries(eis PRIVATE kwin KF6::I18n KF6::GlobalAccel KF6::ConfigGui Libeis::Libeis XKB::XKB)
diff --git a/src/plugins/eis/eisbackend.cpp b/src/plugins/eis/eisbackend.cpp
index b6b12061cd8..3df341fe1a8 100644
--- a/src/plugins/eis/eisbackend.cpp
+++ b/src/plugins/eis/eisbackend.cpp
@@ -27,6 +27,7 @@
 #include <libeis.h>
 
 #include <fcntl.h>
+#include <unistd.h>
 
 #include <ranges>
 
@@ -45,16 +46,18 @@ EisBackend::EisBackend(QObject *parent)
     , m_serviceWatcher(new QDBusServiceWatcher(this))
 {
 #if HAVE_XWAYLAND_ENABLE_EI_PORTAL
-    // Unfortunately there is no way to pass a connected socket fd to libei like WAYLAND_SOCKET
-    // in libwayland so we are resorting to this hack
-    // https://gitlab.freedesktop.org/libinput/libei/-/issues/63
-    m_xWaylandContext = std::make_unique<XWaylandEisContext>(this);
-    FileDescriptor fd(open(m_xWaylandContext->socketName.constData(), O_PATH | O_CLOEXEC));
-    unlink(m_xWaylandContext->socketName.constData());
-    if (QByteArray(kwinApp()->metaObject()->className()) == typeName(KWin::ApplicationWayland)) {
-        auto appWayland = static_cast<ApplicationWayland *>(kwinApp());
-        appWayland->addExtraXWaylandEnvrionmentVariable(QStringLiteral("LIBEI_SOCKET"), QStringLiteral("/proc/self/fd/%1").arg(fd.get()));
-        appWayland->passFdToXwayland(std::move(fd));
+    if (options->xwaylandEisNoPrompt()) {
+        // Unfortunately there is no way to pass a connected socket fd to libei like WAYLAND_SOCKET
+        // in libwayland so we are resorting to this hack
+        // https://gitlab.freedesktop.org/libinput/libei/-/issues/63
+        m_xWaylandContext = std::make_unique<XWaylandEisContext>(this);
+        FileDescriptor fd(open(m_xWaylandContext->socketName.constData(), O_PATH | O_CLOEXEC));
+        unlink(m_xWaylandContext->socketName.constData());
+        if (QByteArray(kwinApp()->metaObject()->className()) == typeName(KWin::ApplicationWayland)) {
+            auto appWayland = static_cast<ApplicationWayland *>(kwinApp());
+            appWayland->addExtraXWaylandEnvrionmentVariable(QStringLiteral("LIBEI_SOCKET"), QStringLiteral("/proc/self/fd/%1").arg(fd.get()));
+            appWayland->passFdToXwayland(std::move(fd));
+        }
     }
 #endif
 
diff --git a/src/xwayland/xwaylandlauncher.cpp b/src/xwayland/xwaylandlauncher.cpp
index df0325862ff..ebec58c3fcf 100644
--- a/src/xwayland/xwaylandlauncher.cpp
+++ b/src/xwayland/xwaylandlauncher.cpp
@@ -177,6 +177,12 @@ bool XwaylandLauncher::start()
 
     arguments << QStringLiteral("-rootless");
 
+#if HAVE_XWAYLAND_ENABLE_EI_PORTAL
+    if (!options->xwaylandEisNoPrompt()) {
+        arguments << QStringLiteral("-enable-ei-portal");
+    }
+#endif
+
     QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
 
     env.insert("WAYLAND_SOCKET", QByteArray::number(waylandSocket.get()));
-- 
GitLab

